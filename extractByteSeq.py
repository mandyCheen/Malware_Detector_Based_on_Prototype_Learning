import pandas as pd
import r2pipe as r2
import concurrent.futures
from multiprocessing import Value

BYTE_LENGTH = 2000
CPU_ARCH = "i386"
DATASET_PATH = f"./dataset/raw_csv/malware_diec_{CPU_ARCH}_byte_sequence{BYTE_LENGTH}_split.csv"
DATASET_FOLDER = "/home/mandy900619/data/Malware202403/"

print(f"Loading {CPU_ARCH} dataset from {DATASET_PATH}...")
dataset = pd.read_csv(DATASET_PATH)

def split_hex_string(hex_string):
    return " ".join([hex_string[i:i+2] for i in range(0, len(hex_string), 2)])

def process_row(row, remaining_files_counter):
    file_path = DATASET_FOLDER + row.file_name[:2] + "/" + row.file_name
    byteAnalysis = r2.open(file_path, flags=["-2"])
    out = byteAnalysis.cmd(f"px* {BYTE_LENGTH}")
    lines = out.strip().split("\n")
    byteSeqence = [line[3:-1] for line in lines if not line.startswith("s-")]
    byteSeqence = "".join(byteSeqence)
    byteSeqence = split_hex_string(byteSeqence)
    try:
        byteAnalysis.quit()
    except:
        pass

    with remaining_files_counter.get_lock():
        remaining_files_counter.value -= 1
        if remaining_files_counter.value % 10 == 0:
            print(f"Remaining files: {remaining_files_counter.value}", end="\r")

    return row.Index, byteSeqence

print(f"Extract byte sequences from {CPU_ARCH} dataset...")
print(f"Extracting byte sequences of length {BYTE_LENGTH}...")

# 只處理 byte_sequence 為空的行
rows_to_process = dataset[dataset['byte_sequence'].isna()].itertuples()
remaining_files_counter = Value('i', len(dataset[dataset['byte_sequence'].isna()]))

with concurrent.futures.ThreadPoolExecutor() as executor:
    futures = [executor.submit(process_row, row, remaining_files_counter) for row in rows_to_process]
    results = [future.result() for future in concurrent.futures.as_completed(futures)]

for index, byteSeqence in results:
    dataset.at[index, "byte_sequence"] = byteSeqence

# 保存更新後的數據集
dataset.to_csv(DATASET_PATH, index=False)
print(f"\nUpdated dataset saved to {DATASET_PATH}")